/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package wmsoftware;

import ij.io.FileSaver;
import ij.ImagePlus;
import ij.ImageStack;
import ij.gui.OvalRoi;
import ij.gui.Plot;
import ij.gui.PlotWindow;
import ij.gui.Roi;
import ij.measure.CurveFitter;
import ij.plugin.ZProjector;
import ij.process.FloatProcessor;
import ij.process.ImageProcessor;
import ij.plugin.filter.*;
import ij.process.Blitter;
import java.awt.Component;
import java.awt.Image;
import java.awt.Polygon;
import java.awt.Rectangle;
import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.NoSuchElementException;

/**
 *
 * @author Meenakshi
 */
public class WMSoftwareGUI extends javax.swing.JFrame {

    private int totalMiceNo;
    private int totalTrialNo;
    private File dir;
    private DataStore[] dss;
    private Component frame;
    private double userBin;
    private int dimX = 240;
    private int dimY = 240;
    private int pX = 175;
    private int pY = 175;

    /**
     * Creates new form WMSoftwareGUI
     */
    public WMSoftwareGUI() {
        initComponents();
        jComboBoxTrialNo.removeAllItems();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jDialog1 = new javax.swing.JDialog();
        jLabel3 = new javax.swing.JLabel();
        buttonGroupPlotGroupDataBy = new javax.swing.ButtonGroup();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldTrials = new javax.swing.JTextField();
        jTextFieldTotalMiceNo = new javax.swing.JTextField();
        jButton1 = new javax.swing.JButton();
        jComboBoxTrialNo = new javax.swing.JComboBox<>();
        jLabel4 = new javax.swing.JLabel();
        jButtonUploadFiles = new javax.swing.JButton();
        jButtonReadFiles = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabelMaps = new javax.swing.JLabel();
        jCheckBoxRDist = new javax.swing.JCheckBox();
        jCheckBoxRVel = new javax.swing.JCheckBox();
        jCheckBoxRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRVelErr = new javax.swing.JCheckBox();
        jButtonCalculateMeasures = new javax.swing.JButton();
        jCheckBoxResTime = new javax.swing.JCheckBox();
        jCheckBoxASCIIvector = new javax.swing.JCheckBox();
        jLabelMaps1 = new javax.swing.JLabel();
        jCheckBoxDivergence = new javax.swing.JCheckBox();
        jCheckBoxCurl = new javax.swing.JCheckBox();
        jCheckBoxGradient = new javax.swing.JCheckBox();
        jButtonGenerateMaps = new javax.swing.JButton();
        jCheckBoxAverageMouse = new javax.swing.JCheckBox();
        jCheckBoxHeatMap = new javax.swing.JCheckBox();
        jPanel3 = new javax.swing.JPanel();
        jCheckBoxRDistvRVel = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelaP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelpP = new javax.swing.JCheckBox();
        jCheckBoxRDistvRVelErr = new javax.swing.JCheckBox();
        jLabelPlots = new javax.swing.JLabel();
        jLabel5 = new javax.swing.JLabel();
        jTextFieldUserBin = new javax.swing.JTextField();
        jButtonGeneratePlots = new javax.swing.JButton();
        jCheckBoxAverageMousePlot = new javax.swing.JCheckBox();

        jDialog1.setTitle("Select files");
        jDialog1.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        jDialog1.setModalityType(java.awt.Dialog.ModalityType.DOCUMENT_MODAL);

        jLabel3.setText("Select files for each trial:");

        javax.swing.GroupLayout jDialog1Layout = new javax.swing.GroupLayout(jDialog1.getContentPane());
        jDialog1.getContentPane().setLayout(jDialog1Layout);
        jDialog1Layout.setHorizontalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(jLabel3)
                .addContainerGap(259, Short.MAX_VALUE))
        );
        jDialog1Layout.setVerticalGroup(
            jDialog1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jDialog1Layout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addComponent(jLabel3)
                .addContainerGap(260, Short.MAX_VALUE))
        );

        jDialog1.getAccessibleContext().setAccessibleParent(jButton1);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Water Maze Software");

        jLabel1.setText("Number of mice per trial:");

        jLabel2.setText("Total number of trials:");

        jButton1.setText("Select Files");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jComboBoxTrialNo.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));

        jLabel4.setText("Trial number:");

        jButtonUploadFiles.setText("Upload Files");
        jButtonUploadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonUploadFilesActionPerformed(evt);
            }
        });

        jButtonReadFiles.setText("Read Files");
        jButtonReadFiles.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonReadFilesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(jTextFieldTrials, javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 94, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonUploadFiles)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonReadFiles)
                        .addGap(0, 287, Short.MAX_VALUE))))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jTextFieldTotalMiceNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(jTextFieldTrials, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jButton1)
                .addGap(18, 18, 18)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(jComboBoxTrialNo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonUploadFiles)
                    .addComponent(jButtonReadFiles))
                .addContainerGap(184, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Select Files", jPanel1);

        jLabelMaps.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps.setText("Measures:");

        jCheckBoxRDist.setText("Displacement");

        jCheckBoxRVel.setText("Velocity");

        jCheckBoxRVelaP.setText("Velocity along platform");

        jCheckBoxRVelpP.setText("Velocity perpendicular to platform");

        jCheckBoxRVelErr.setText("Velocity Error");

        jButtonCalculateMeasures.setText("Calculate");
        jButtonCalculateMeasures.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonCalculateMeasuresActionPerformed(evt);
            }
        });

        jCheckBoxResTime.setText("Residence Time");

        jCheckBoxASCIIvector.setText("ASCII vector");

        jLabelMaps1.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelMaps1.setText("Maps:");

        jCheckBoxDivergence.setText("Divergence map");

        jCheckBoxCurl.setText("Curl map");

        jCheckBoxGradient.setText("Gradient map");

        jButtonGenerateMaps.setText("Generate Maps");
        jButtonGenerateMaps.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGenerateMapsActionPerformed(evt);
            }
        });

        jCheckBoxAverageMouse.setText("Average Mouse");

        jCheckBoxHeatMap.setText("Heat Map");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxResTime)
                    .addComponent(jLabelMaps)
                    .addComponent(jCheckBoxRDist)
                    .addComponent(jCheckBoxRVelpP)
                    .addComponent(jCheckBoxRVel)
                    .addComponent(jCheckBoxRVelaP)
                    .addComponent(jButtonCalculateMeasures)
                    .addComponent(jCheckBoxRVelErr))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 8, Short.MAX_VALUE)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxASCIIvector)
                    .addComponent(jLabelMaps1)
                    .addComponent(jCheckBoxGradient)
                    .addComponent(jCheckBoxDivergence)
                    .addComponent(jCheckBoxCurl)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(105, 105, 105)
                        .addComponent(jCheckBoxAverageMouse))
                    .addComponent(jButtonGenerateMaps)
                    .addComponent(jCheckBoxHeatMap))
                .addGap(191, 191, 191))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabelMaps)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxResTime)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRDist)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVelaP)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxRVelpP))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabelMaps1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxASCIIvector)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxDivergence)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxCurl)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxHeatMap)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxGradient)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxRVelErr)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(30, 30, 30)
                        .addComponent(jCheckBoxAverageMouse)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButtonCalculateMeasures)
                    .addComponent(jButtonGenerateMaps))
                .addContainerGap(91, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Generate Maps", jPanel2);

        jCheckBoxRDistvRVel.setText("R-Distance vs R-Velocity");

        jCheckBoxRDistvRVelaP.setText("R-Distance vs R-Velocity along platform");

        jCheckBoxRDistvRVelpP.setText("R-Distance vs R-Velocity perpendicular to platform");

        jCheckBoxRDistvRVelErr.setText("R-Distance vs R-Velocity Errors");

        jLabelPlots.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jLabelPlots.setText("Plots:");

        jLabel5.setText("Enter bin width in X:");

        jTextFieldUserBin.setText("0.00");

        jButtonGeneratePlots.setText("Generate Plots");
        jButtonGeneratePlots.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonGeneratePlotsActionPerformed(evt);
            }
        });

        jCheckBoxAverageMousePlot.setText("Average Mouse");

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addComponent(jButtonGeneratePlots)
                .addGap(0, 0, Short.MAX_VALUE))
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jCheckBoxAverageMousePlot)
                    .addComponent(jLabelPlots)
                    .addComponent(jCheckBoxRDistvRVelErr)
                    .addComponent(jCheckBoxRDistvRVelpP)
                    .addComponent(jCheckBoxRDistvRVelaP)
                    .addComponent(jCheckBoxRDistvRVel)
                    .addGroup(jPanel3Layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, 51, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(325, Short.MAX_VALUE))
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel3Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel5)
                    .addComponent(jTextFieldUserBin, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jLabelPlots)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelaP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelpP)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jCheckBoxRDistvRVelErr)
                .addGap(17, 17, 17)
                .addComponent(jCheckBoxAverageMousePlot)
                .addGap(18, 18, 18)
                .addComponent(jButtonGeneratePlots)
                .addContainerGap(69, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Generate Plots", jPanel3);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane1)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonCalculateMeasuresActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonCalculateMeasuresActionPerformed
        //BitSet for measures
        BitSet bs = new BitSet(6);
        bs.set(0, jCheckBoxResTime.isSelected());
        bs.set(1, jCheckBoxRDist.isSelected());
        bs.set(2, jCheckBoxRVel.isSelected());
        bs.set(3, jCheckBoxRVelaP.isSelected());
        bs.set(4, jCheckBoxRVelpP.isSelected());
        bs.set(5, jCheckBoxRVelErr.isSelected());

        //loop through measures to be calculated
        for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
            String resultName = "";

            //loop through trials
            for (DataStore ds : dss) {
                HashMap PositionHM = ds.getHMap("Position");
                HashMap resultHMap = new HashMap<>();
                //loop through mice
                for (int mouse = 0; mouse < ds.getTotalMice(); mouse++) {
                    DataTrace_ver1 series = (DataTrace_ver1) PositionHM.get(mouse);
                    Object result = null;
//                    DataTrace_ver1 result = null;

                    //calculations
                    switch (i) {
                        case 0:
                            resultName = "Residence Time";
                            ArrayList<Double> resTimeArray = this.residenceTime(series);
                            ImageProcessor ipResTime = new FloatProcessor(dimX, dimY);
                            float[][] arrayResTime = new float[dimX][dimY];
                            for (int Y = 0; Y < dimY; Y++) {
                                for (int X = 0; X < dimX; X++) {
                                    int arrayIdx = (Y * dimX) + X;
                                    arrayResTime[X][Y] = resTimeArray.get(arrayIdx).floatValue();
                                }
                            }
                            ipResTime.setFloatArray(arrayResTime);
                            result = ipResTime;
                            break;

                        case 1: //displacement
                            resultName = "Displacement";
                            result = this.displacementVector(series);
                            break;

                        case 2: //velocity
                            resultName = "Velocity";
                            result = this.velocityVector(series);
                            break;

                        case 3: //vel along pt
                            resultName = "Velocity along Platform";
                            result = this.velocityAlongPt(series);
                            break;

                        case 4: //vel perpendicular pt
                            resultName = "Velocity perpendicular Platform";
                            result = this.velocityPerpendicularPt(series);
                            break;

                        case 5: //vel err
                            resultName = "Velocity Error";
                            result = this.velocityErrorVector(series);
                            break;
                    }
                    //put calculated measure in a hashmap
                    resultHMap.put(mouse, result);
                }
                //put calculated hashmap into datastore
                ds.setHMap(resultName, resultHMap);
            }
            if (i == Integer.MAX_VALUE) {
                break;
            }
        }

        //////                            ip = image.getProcessor();
        //////                            ip.invert(); //so minima can be maxima
        //////
        //////                            //Find maxima within the pool ROI
        //////                            OvalRoi pool = new OvalRoi(0, 0, 240, 240);
        //////                            //find maxima
        //////                            MaximumFinder mf = new MaximumFinder();
        //////                            Polygon maximas = mf.getMaxima(ip, 0.00001, true); //excludes edges
        ////////                        System.out.println("Find Maxima: XCoord " + Arrays.toString(maximas.xpoints));
        ////////                        System.out.println("Find Maxima: YCoord " + Arrays.toString(maximas.ypoints));
        ////////                        System.out.println("Points: " + maximas.npoints + Arrays.toString(maximas.xpoints) + Arrays.toString(maximas.ypoints));
        //////
        //////                            ArrayList<Float> RmList = new ArrayList<>();
        //////                            ArrayList<Float> intensity = new ArrayList<>();
        //////                            int xb = (int) bounds.getX();
        //////                            int yb = (int) bounds.getY();
        //////                            for (int ii = 0; ii < maximas.npoints; ii++) {
        //////                                int X = maximas.xpoints[ii] + xb;
        //////                                int Y = maximas.ypoints[ii] + yb;
        //////                                if (pool.containsPoint(X, Y)) {
        //////                                    intensity.add(ip.getPixelValue(maximas.xpoints[ii], maximas.ypoints[ii]));
        //////                                    float Rm = (float) Math.sqrt(Math.pow((175 - X), 2) + Math.pow((175 - Y), 2));
        //////                                    RmList.add(Rm);
        //////                                }
        //////                            }
        //////                            float Rm;
        //////                            try {
        //////                                float max_intensity = Collections.max(intensity);
        //////                                int index = intensity.indexOf(max_intensity);
        //////                                Rm = RmList.get(index);
        //////                            } catch (NoSuchElementException c) {
        //////                                Rm = Float.NaN;
        //////                            }
        //////                            System.out.println("Rm list for all maximas UNSORTED: " + RmList);
        //////                            Collections.sort(RmList);
        //////                            System.out.println("Rm list for all maximas: " + RmList);
        //////                            HashMap rmHMap = ds.getHMap(resultName + " Rm Map") == null ? new HashMap<>() : ds.getHMap(resultName + " Rm Map");
        //////                            rmHMap.put(mouse, Rm);
        //////                            ds.setHMap(resultName + " Rm Map", rmHMap);
        //////
        //////                            //resize image to 240 by 240 dimension
        //////                            float[][] processedArray = new float[dimX][dimY];
        //////                            for (int Y = 0; Y < dimY; Y++) {
        //////                                for (int X = 0; X < dimX; X++) {
        //////                                    processedArray[X][Y] = Float.NaN;
        //////                                    //processedArray[X][Y] = 0;
        //////                                }
        //////                            }
        ////////                        int xb = (int) bounds.getX();  //already defined above
        ////////                        int yb = (int) bounds.getY();  // already defined above
        //////                            int xbmax = (int) bounds.getWidth();
        //////                            int ybmax = (int) bounds.getHeight();
        //////                            float[][] f = ip.getFloatArray();
        //////                            for (int Y = 0; Y < ybmax; Y++) {
        //////                                for (int X = 0; X < xbmax; X++) {
        //////                                    if (pool.containsPoint(X + xb, Y + yb)) {
        //////                                        processedArray[X + xb][Y + yb] = f[X][Y];
        //////                                    }
        //////                                }
        //////                            }
        //////                            ImageProcessor processedip = new FloatProcessor(processedArray);
        //////                            map.saveHeatMap(resultName + "processed_T" + ds_counter + "_M" + mouse, processedip);
        //////                        }
        System.out.println("Button click done.");
    }//GEN-LAST:event_jButtonCalculateMeasuresActionPerformed

    private void jButtonReadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonReadFilesActionPerformed
        //reads the file and creates DataTrace for each file/mouse, in each trial
        for (DataStore ds : dss) {
            ds.readFile();
        }
        //print dialog box
        JOptionPane.showMessageDialog(frame, "Files read.", "Task completed", JOptionPane.INFORMATION_MESSAGE);
    }//GEN-LAST:event_jButtonReadFilesActionPerformed

    private void jButtonUploadFilesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonUploadFilesActionPerformed
        //choose multiple files
        JFileChooser Fc = new JFileChooser();
        Fc.setMultiSelectionEnabled(true);
        Fc.showOpenDialog(this);
        //creates DataStore for selected trial no.
        int index = jComboBoxTrialNo.getSelectedIndex();
        if (totalMiceNo != Fc.getSelectedFiles().length) {
            JOptionPane.showMessageDialog(frame, "Number of files selected does not match number of mice.", "ERROR", JOptionPane.ERROR_MESSAGE);
        } else {
            dss[index] = new DataStore(totalMiceNo, Fc.getSelectedFiles());
        }
    }//GEN-LAST:event_jButtonUploadFilesActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        jComboBoxTrialNo.removeAllItems();
        try {
            totalTrialNo = Integer.parseInt(jTextFieldTrials.getText());
            totalMiceNo = Integer.parseInt(jTextFieldTotalMiceNo.getText());
            if (totalTrialNo == 0 || totalMiceNo == 0) {
                JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
                return;
            }
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(frame, "Enter valid number.", "ERROR", JOptionPane.ERROR_MESSAGE);
        }
        //create checkbox with total trial no.
        for (int i = 0; i < totalTrialNo; i++) {
            jComboBoxTrialNo.addItem(Integer.toString(i + 1));
        }
        //create array for DataStore of all trials
        dss = new DataStore[totalTrialNo];
    }//GEN-LAST:event_jButton1ActionPerformed

    private void jButtonGenerateMapsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGenerateMapsActionPerformed
// 13.01.2020 - 12.05am - check out label, i.e. the goto version of java, for the map generation code

        //Select directory to store files
        JFileChooser Fc = new JFileChooser();
        Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        Fc.showOpenDialog(this);
        dir = Fc.getSelectedFile();

        //BitSet for measures
        BitSet bs = new BitSet(6);
        bs.set(0, jCheckBoxResTime.isSelected());
        bs.set(1, jCheckBoxRDist.isSelected());
        bs.set(2, jCheckBoxRVel.isSelected());
        bs.set(3, jCheckBoxRVelaP.isSelected());
        bs.set(4, jCheckBoxRVelpP.isSelected());
        bs.set(5, jCheckBoxRVelErr.isSelected());

        //BitSet for user selected output file type
        BitSet bs2 = new BitSet(5);
        bs2.set(0, jCheckBoxASCIIvector.isSelected());
        bs2.set(1, jCheckBoxDivergence.isSelected());
        bs2.set(2, jCheckBoxCurl.isSelected());
        bs2.set(3, jCheckBoxHeatMap.isSelected());
        bs2.set(4, jCheckBoxGradient.isSelected());
//        bs2.set(1, jCheckBoxxImg.isSelected());
//        bs2.set(2, jCheckBoxyImg.isSelected());

        String resultHMapName = "";
        for (int i = bs.nextSetBit(1); i >= 0; i = bs.nextSetBit(i + 1)) {

            switch (i) {
//                case 0: //Residence Time
//                    resultHMapName = "Residence Time";
//                    break;
                case 1: //Displacement
                    resultHMapName = "Displacement";
                    break;
                case 2: //Velocity
                    resultHMapName = "Velocity";
                    break;
                case 3: //Velocity a pt
                    resultHMapName = "Velocity along Platform";
                    break;
                case 4: //Velocity p pt
                    resultHMapName = "Velocity perpendicular Platform";
                    break;
                case 5: //Velocity Error
                    resultHMapName = "Velocity Error";
                    break;
            }

            //Method 1.2 -
            //doesnt work with restime selection
            //loop through other selections
            String output = "";
            for (int j = bs2.nextSetBit(0); j >= 0; j = bs2.nextSetBit(j + 1)) {
                int ds_counter = 0;
                ImageStack trialResultStack = new ImageStack(dimX, dimY);
                for (DataStore ds : dss) {
                    HashMap PositionHMap = ds.getHMap("Position");
                    HashMap HMap = ds.getHMap(resultHMapName);

                    //initialisation
                    ImageStack resTimeStack = new ImageStack(dimX, dimY);
                    ImageStack xImgStack = new ImageStack(dimX, dimY);
                    ImageStack yImgStack = new ImageStack(dimX, dimY);
                    ImageStack imgStack = new ImageStack(dimX, dimY);
                    ImageStack resultStack = new ImageStack();
                    ImagePlus result = null, xImage = null, yImage = null, image = null;
                    HashMap ResTimeHMap = ds.getHMap("Residence Time");

                    for (int mouse = 0; mouse < ds.getTotalMice(); mouse++) {
                        DataTrace_ver1 series = (DataTrace_ver1) PositionHMap.get(mouse);
                        DataTrace_ver1 measure = (DataTrace_ver1) HMap.get(mouse);

                        if (ResTimeHMap == null) {
                            JOptionPane.showMessageDialog(frame, "Please calculate Residence Time.", "ERROR", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                        //resTime
                        ImageProcessor ipResTime = (ImageProcessor) ResTimeHMap.get(mouse);
                        resTimeStack.addSlice(ipResTime);

                        if (j < 3) {
                            //for vector map, div and curl
                            //create sumPixels image
                            xImage = this.sumPixelsImage(series, measure.getX());
                            yImage = this.sumPixelsImage(series, measure.getY());
                            xImgStack.addSlice(xImage.getProcessor());
                            yImgStack.addSlice(yImage.getProcessor());
                            //ResTime weighted
                            //CANNOT average by dividing sumPixels image with resTime - AS IT CREATES NaNs :(
                            xImage = this.resTimeWeightedMap(ipResTime, xImage.getProcessor());
                            yImage = this.resTimeWeightedMap(ipResTime, yImage.getProcessor());
                        } else {
                            //for heat map and gradient
                            //create sumPixels image
                            ArrayList<Double> rMeasure = this.vectorMagnitude(measure);
                            image = this.sumPixelsImage(series, rMeasure);
                            imgStack.addSlice(image.getProcessor());
                            //restime weighted
                            image = this.resTimeWeightedMap(ipResTime, image.getProcessor());
                        }

                        switch (j) {
                            case 0:
                                //write vector measure into an ascii file
                                output = "vector";
                                result = this.vectorMap(xImage, yImage, resultHMapName);
                                break;
                            case 1: //Divergence
                                output = "div";
                                xImage = this.thresholdedSurfaceFit3(ipResTime, xImage);
                                yImage = this.thresholdedSurfaceFit3(ipResTime, yImage);
                                result = this.resizeImage(ipResTime, this.divergence(xImage, yImage).getProcessor());
                                break;
                            case 2: //Curl
                                output = "curl";
                                xImage = this.thresholdedSurfaceFit3(ipResTime, xImage);
                                yImage = this.thresholdedSurfaceFit3(ipResTime, yImage);
                                result = this.resizeImage(ipResTime, this.curl(xImage, yImage).getProcessor());
                                break;
                            case 3: //Heat map
                                output = "hm";
                                result = image;
                                break;
                            case 4: //Gradient
                                output = "grad";
                                image = this.thresholdedSurfaceFit3(ipResTime, image);
                                result = this.resizeImage(ipResTime, this.gradient(image).getProcessor());
                                break;
                        }
                        if (ds.getTotalMice() == 1) {
                            //save individual file if only 1 mouse per trial
                            this.saveHeatMap(resultHMapName + "_" + output + "_T" + ds_counter + "_M" + mouse, result.getProcessor());
                        } else {
                            //add to stack if more than 1 mouse per trial
                            resultStack.addSlice(result.getProcessor());
                        }
                        //mouse over
                    }
                    if (ds.getTotalMice() != 1) {
                        //save stack
                        ImagePlus resultStackImp = new ImagePlus(resultHMapName + "_" + output + "_T" + ds_counter, resultStack);
                        new FileSaver(resultStackImp).saveAsTiffStack(dir.getPath() + File.separator + resultStackImp.getTitle() + ".tif");
                    }

                    //average mouse calculations go here
                    if (jCheckBoxAverageMouse.isSelected() && j != 0) {
                        ImagePlus resTimeStackImp = new ImagePlus("ResTime_" + output + "_T" + ds_counter, resTimeStack);
                        ImagePlus aveResTime = ZProjector.run(resTimeStackImp, "sum");
                        ImagePlus aveXImage = null, aveYImage = null, aveImage = null;

                        if (j < 3) {
                            ImagePlus xImgStackImp = new ImagePlus("xImg_" + resultHMapName + "_" + output + "_T" + ds_counter, xImgStack);
                            ImagePlus yImgStackImp = new ImagePlus("yImg_" + resultHMapName + "_" + output + "_T" + ds_counter, yImgStack);
                            aveXImage = ZProjector.run(xImgStackImp, "sum");
                            aveYImage = ZProjector.run(yImgStackImp, "sum");
                            //restime weighted
                            aveXImage = this.resTimeWeightedMap(aveResTime.getProcessor(), aveXImage.getProcessor());
                            aveYImage = this.resTimeWeightedMap(aveResTime.getProcessor(), aveYImage.getProcessor());
                        } else {
                            ImagePlus imgStackImp = new ImagePlus("img_" + resultHMapName + "_" + output + "_T" + ds_counter, imgStack);
                            aveImage = ZProjector.run(imgStackImp, "sum");
                            //restime weighted
                            aveImage = this.resTimeWeightedMap(aveResTime.getProcessor(), aveImage.getProcessor());
                        }
                        switch (j) {
                            case 0:
                                //write vector measure into an ascii file
                                output = "vector";
                                result = this.vectorMap(aveXImage, aveYImage, resultHMapName);
                                break;
                            case 1: //Divergence
                                output = "div";
                                aveXImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveXImage);
                                aveYImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveYImage);
                                result = this.resizeImage(aveResTime.getProcessor(), this.divergence(aveXImage, aveYImage).getProcessor());
                                break;
                            case 2: //Curl
                                output = "curl";
                                aveXImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveXImage);
                                aveYImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveYImage);
                                result = this.resizeImage(aveResTime.getProcessor(), this.curl(aveXImage, aveYImage).getProcessor());
                                break;
                            case 3: //hm
                                output = "hm";
                                result = aveImage;
                                break;
                            case 4: //Gradient
                                output = "grad";
                                aveImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveImage);
                                result = this.resizeImage(aveResTime.getProcessor(), this.gradient(aveImage).getProcessor());
                                break;
                        }
                        if (dss.length != 1) {
                            //add ave mouse of a trial to trial stack
                            trialResultStack.addSlice(result.getProcessor());
                        } else {
                            this.saveHeatMap(resultHMapName + "_" + output + "_T" + ds_counter + "_aveM", result.getProcessor());
                        }
                    }
                    //trial completed.
                    ds_counter++;
                    System.out.println("Trial no. = " + ds_counter);
                }
                if (jCheckBoxAverageMouse.isSelected() && dss.length != 1) {
                    //save stack of ave of all trials
                    ImagePlus trialResultStackImp = new ImagePlus(resultHMapName + "_" + output, trialResultStack);
                    new FileSaver(trialResultStackImp).saveAsTiffStack(dir.getPath() + File.separator + trialResultStackImp.getTitle() + ".tif");
                }
                if (j == Integer.MAX_VALUE) {
                    break;
                }
            }
            System.out.println("Output Measure name: " + output + " " + resultHMapName + " completed");

            if (i == Integer.MAX_VALUE) {
                break;
            }
        }
        System.out.println("Button click done.");

////////            
////////            //Method 1 - really messed up my mind to be honest
////////            //doesnt work with restime selection
////////            //loop through other selections
////////            String output = "";
////////            for (int j = bs2.nextSetBit(0); j >= 0; j = bs2.nextSetBit(j + 1)) {
////////
////////                int ds_counter = 0;
////////                ImageStack trialResultStack = new ImageStack(dimX, dimY);
////////                for (DataStore ds : dss) {
////////                    HashMap PositionHMap = ds.getHMap("Position");
////////                    HashMap HMap = ds.getHMap(resultHMapName);
////////                    ImageStack resTimeStack = new ImageStack(dimX, dimY);
////////                    ImageStack xImgStack = new ImageStack(dimX, dimY);
////////                    ImageStack yImgStack = new ImageStack(dimX, dimY);
////////                    ImageStack imgStack = new ImageStack(dimX, dimY);
////////                    ImageStack resultStack = new ImageStack();
////////
////////                    //initialisation
////////                    ImageProcessor ipResTime = null;
////////                    ImagePlus result = null, xImage = null, yImage = null, image = null;
////////                    HashMap ResTimeHMap = ds.getHMap("Residence Time");
////////
////////                    for (int mouse = 0; mouse < ds.getTotalMice(); mouse++) {
////////                        DataTrace_ver1 series = (DataTrace_ver1) PositionHMap.get(mouse);
////////                        DataTrace_ver1 measure = (DataTrace_ver1) HMap.get(mouse);
////////
////////                        if (j != 0) {
////////                            if (ResTimeHMap == null) {
////////                                JOptionPane.showMessageDialog(frame, "Please calculate Residence Time.", "ERROR", JOptionPane.ERROR_MESSAGE);
////////                                return;
////////                            }
////////                            //resTime
////////                            ipResTime = (ImageProcessor) ResTimeHMap.get(mouse);
////////                            resTimeStack.addSlice(ipResTime);
////////
////////                            if (j == 1 || j == 2) {
////////                                //for div and curl
////////                                xImage = this.createImage(series, measure.getX());
////////                                yImage = this.createImage(series, measure.getY());
////////                                xImgStack.addSlice(xImage.getProcessor());
////////                                yImgStack.addSlice(yImage.getProcessor());
////////                                xImage = this.thresholdedSurfaceFit3(ipResTime, xImage);
////////                                yImage = this.thresholdedSurfaceFit3(ipResTime, yImage);
////////                            } else {
////////                                //for heat map and gradient
////////                                ArrayList<Double> rMeasure = this.vectorMagnitude(measure);
////////                                image = this.createImage(series, rMeasure);
////////                                imgStack.addSlice(image.getProcessor());
////////                            }
////////                        }
////////
////////                        switch (j) {
////////                            case 0:
////////                                //write vector measure into an ascii file
////////                                output = "vector";
////////                                DataTrace_ver1 measureOut = new DataTrace_ver1();
////////                                for (int ii = 0; ii < measure.size(); ii++) {
////////                                    double xVal = series.get(ii).getX().doubleValue() + measure.get(ii).getX().doubleValue();
////////                                    double yVal = series.get(ii).getY().doubleValue() + measure.get(ii).getY().doubleValue();
////////                                    measureOut.addData(xVal, yVal);
////////                                }
////////                                //write ascii
//////////                            ds.writeFile(resultHMapName + "_T" + ds_counter + "_M" + mouse, dir.getAbsolutePath(), series, measureOut);
////////                                //plot vectors
////////                                ArrayList<Double> X1 = (ArrayList<Double>) measureOut.getX();
////////                                ArrayList<Double> Y1 = (ArrayList<Double>) measureOut.getY();
////////                                ArrayList<Double> X0 = (ArrayList<Double>) series.getX();
////////                                X0.remove(X0.get(X1.size()));
////////                                ArrayList<Double> Y0 = (ArrayList<Double>) series.getY();
////////                                Y0.remove(Y0.get(Y1.size()));
////////                                Plot vectorMap = new Plot(resultHMapName + " vector plot", "X Axis", "Y Axis");
////////                                vectorMap.setLimits(0, dimX, 0, dimY);
////////                                vectorMap.drawVectors(X0, Y0, X1, Y1);
////////                                vectorMap.show();
////////                                result = vectorMap.getImagePlus();
//////////                                result = vectorMap.makeHighResolution(vectorMap.getTitle(), 1, true, true);
////////                                break;
////////                            case 1: //Divergence
////////                                output = "div";
////////                                result = this.resizeImage(ipResTime, this.divergence(xImage, yImage).getProcessor());
////////                                break;
////////                            case 2: //Curl
////////                                output = "curl";
////////                                result = this.resizeImage(ipResTime, this.curl(xImage, yImage).getProcessor());
////////                                break;
////////                            case 3: //Heat map
////////                                output = "hm";
////////                                result = image;
////////                                break;
////////                            case 4: //Gradient
////////                                output = "grad";
////////                                result = this.resizeImage(ipResTime, this.gradient(image).getProcessor());
////////                                break;
////////                        }
////////                        if (ds.getTotalMice() == 1) {
////////                            //save individual file if only 1 mouse per trial
////////                            this.saveHeatMap(resultHMapName + "_" + output + "_T" + ds_counter + "_M" + mouse, result.getProcessor());
////////                        } else {
////////                            //add to stack if more than 1 mouse per trial
////////                            resultStack.addSlice(result.getProcessor());
////////                        }
////////                        //mouse over
////////                    }
////////                    if (ds.getTotalMice() != 1) {
////////                        //save stack
////////                        ImagePlus resultStackImp = new ImagePlus(resultHMapName + "_" + output + "_T" + ds_counter, resultStack);
////////                        new FileSaver(resultStackImp).saveAsTiffStack(dir.getPath() + File.separator + resultStackImp.getTitle() + ".tif");
////////                    }
////////
////////                    //average mouse calculations go here
////////                    if (jCheckBoxAverageMouse.isSelected() && j != 0) {
////////                        ImagePlus resTimeStackImp = new ImagePlus("ResTime_" + output + "_T" + ds_counter, resTimeStack);
////////                        ImagePlus aveResTime = ZProjector.run(resTimeStackImp, "sum");
////////                        ImagePlus aveXImage = null, aveYImage = null, aveImage = null;
////////
////////                        if (j == 1 || j == 2) {
////////                            ImagePlus xImgStackImp = new ImagePlus("xImg_" + resultHMapName + "_" + output + "_T" + ds_counter, xImgStack);
////////                            ImagePlus yImgStackImp = new ImagePlus("yImg_" + resultHMapName + "_" + output + "_T" + ds_counter, yImgStack);
////////                            ImagePlus avexImg = ZProjector.run(xImgStackImp, "sum");
////////                            ImagePlus aveyImg = ZProjector.run(yImgStackImp, "sum");
////////                            aveXImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), avexImg);
////////                            aveYImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveyImg);
////////                        } else {
////////                            ImagePlus imgStackImp = new ImagePlus("img_" + resultHMapName + "_" + output + "_T" + ds_counter, imgStack);
////////                            aveImage = ZProjector.run(imgStackImp, "sum");
////////                        }
////////                        switch (j) {
////////                            case 1: //Divergence
////////                                output = "div";
////////                                result = this.resizeImage(aveResTime.getProcessor(), this.divergence(aveXImage, aveYImage).getProcessor());
////////                                break;
////////                            case 2: //Curl
////////                                output = "curl";
////////                                result = this.resizeImage(aveResTime.getProcessor(), this.curl(aveXImage, aveYImage).getProcessor());
////////                                break;
////////                            case 3: //hm
////////                                output = "hm";
////////                                result = aveImage;
////////                                break;
////////                            case 4: //Gradient
////////                                output = "grad";
////////                                aveImage = this.thresholdedSurfaceFit3(aveResTime.getProcessor(), aveImage);
////////                                result = this.resizeImage(aveResTime.getProcessor(), this.gradient(aveImage).getProcessor());
////////                                break;
////////                        }
////////                        if (dss.length != 1) {
////////                            //add ave mouse of a trial to trial stack
////////                            trialResultStack.addSlice(result.getProcessor());
////////                        } else {
////////                            this.saveHeatMap(resultHMapName + "_" + output + "_T" + ds_counter + "_aveM", result.getProcessor());
////////                        }
////////                    }
////////                    //trial completed.
////////                    ds_counter++;
////////                    System.out.println("Trial no. = " + ds_counter);
////////                }
////////                if (jCheckBoxAverageMouse.isSelected() && dss.length != 1) {
////////                    //save stack of ave of all trials
////////                    ImagePlus trialResultStackImp = new ImagePlus(resultHMapName + "_" + output, trialResultStack);
////////                    new FileSaver(trialResultStackImp).saveAsTiffStack(dir.getPath() + File.separator + trialResultStackImp.getTitle() + ".tif");
////////                }
////////                if (j == Integer.MAX_VALUE) {
////////                    break;
////////                }
////////            }
////////            System.out.println("Output Measure name: " + output + " " + resultHMapName + " completed");
////////
////////            if (i == Integer.MAX_VALUE) {
////////                break;
////////            }
////////        }
////////        System.out.println("Button click done.");
    }//GEN-LAST:event_jButtonGenerateMapsActionPerformed

    private void jButtonGeneratePlotsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonGeneratePlotsActionPerformed
        //Select directory to store files
        JFileChooser Fc = new JFileChooser();
        Fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        Fc.showOpenDialog(this);
        dir = Fc.getSelectedFile();

        if (dir == null) {
            JOptionPane.showMessageDialog(frame, "Please select directory to save plots.", "ERROR", JOptionPane.ERROR_MESSAGE);
            return;
        }

        int ds_counter = 0;
        for (DataStore ds : dss) {
            HashMap dispHMap = ds.getHMap("Displacement");
            if (dispHMap == null) {
                JOptionPane.showMessageDialog(frame, "Please calculate displacement.", "ERROR", JOptionPane.ERROR_MESSAGE);
                return;
            }
            //bitset for user selection of distvmeasure plot
            BitSet bs = new BitSet(4);
            bs.set(0, jCheckBoxRDistvRVel.isSelected());
            bs.set(1, jCheckBoxRDistvRVelaP.isSelected());
            bs.set(2, jCheckBoxRDistvRVelpP.isSelected());
            bs.set(3, jCheckBoxRDistvRVelErr.isSelected());

            //bin size for binning values
            userBin = Double.parseDouble(jTextFieldUserBin.getText());

            //loop through user selections
            for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {
                String resultName = "";
                switch (i) {

                    case 0: //rvel
                        resultName = "Velocity";
                        break;

                    case 1: //rvel along pt
                        resultName = "Velocity along Platform";
                        break;

                    case 2://rvel p pt
                        resultName = "Velocity perpendicular Platform";
                        break;

                    case 3://vel err
                        resultName = "Velocity Error";
                        break;
                }

                HashMap resultHMap = resultHMap = ds.getHMap(resultName);
                if (resultHMap == null) {
                    JOptionPane.showMessageDialog(frame, "Please calculate " + resultName + ".", "ERROR", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                HashMap rmHMap = ds.getHMap("Rm Plot") == null ? new HashMap<>() : ds.getHMap("Rm Plot");
                HashMap rmFloatHMap = new HashMap<Integer, Float>();

                //loop over individual mouse
                DataTrace_ver1 aveDistVMeasure = new DataTrace_ver1();
                for (int mouse = 0; mouse < ds.getTotalMice(); mouse++) {
                    DataTrace_ver1 DispDt = (DataTrace_ver1) dispHMap.get(mouse);
                    DataTrace_ver1 resultDt = (DataTrace_ver1) resultHMap.get(mouse);
                    ArrayList<Double> dist = this.vectorMagnitude(DispDt);
                    ArrayList<Double> result = this.vectorMagnitude(resultDt);

                    //add x,y data to datatrace for binning
                    DataTrace_ver1 distVmeasure = new DataTrace_ver1();
                    for (int j = 0; j < dist.size() && j < result.size(); j++) {
                        distVmeasure.addData(dist.get(j), result.get(j));
                        aveDistVMeasure.addData(dist.get(j), result.get(j));
                    }
                    //binInX and DO NOT restore original order
                    distVmeasure = distVmeasure.binData(userBin, true, false);
                    float Rm = this.RmFromPolynomialFit(distVmeasure, resultName + "_T" + ds_counter, String.valueOf(mouse));
                    rmFloatHMap.put(mouse, Rm);
                }
                if (jCheckBoxAverageMousePlot.isSelected()) {
                    aveDistVMeasure = aveDistVMeasure.binData(userBin, true, false);
                    float Rm = this.RmFromPolynomialFit(aveDistVMeasure, resultName + "_T" + ds_counter, "Ave");
                    rmFloatHMap.put(ds.getTotalMice(), Rm);
                }
                rmHMap.put(resultName, rmFloatHMap);
                ds.setHMap("Rm Plot", rmHMap);
                if (i == Integer.MAX_VALUE) {
                    break;
                }
            }
            ds_counter++;
        }
        System.out.println("End of button press");
    }//GEN-LAST:event_jButtonGeneratePlotsActionPerformed

    /**
     * Calculate vector magnitude i.e. r
     */
    private ArrayList<Double> vectorMagnitude(DataTrace_ver1 series) {
        ArrayList<Double> result = new ArrayList<>();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            result.add(i, (Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2))));
        }
        return result;
    }

    /**
     * Calculate vector angle i.e. theta
     */
    private ArrayList<Double> vectorAngle(DataTrace_ver1 series) {
        ArrayList<Double> result = new ArrayList<>();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            if (x != 0) {
                result.add(i, Math.atan2(y, x)); //How to deal with x=0 error?
            } else {
                result.add(i, Double.MAX_VALUE);
            }
        }
        return result;
    }

    /**
     * Calculate (x(i+1) - x(i), y(i+1) - y(i))
     */
    private DataTrace_ver1 getSuccessiveDifference(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        for (int i = 0; i < (series.size() - 1); i++) {
            double x1 = series.get(i).getX().doubleValue();
            double x2 = series.get(i + 1).getX().doubleValue();
            double y1 = series.get(i).getY().doubleValue();
            double y2 = series.get(i + 1).getY().doubleValue();
            result.addData((x2 - x1), (y2 - y1));
        }
        return result;
    }

    /**
     * Calculate residence time
     */
    private ArrayList<Double> residenceTime(DataTrace_ver1 series) {
        ArrayList<Double> resTime = new ArrayList();
        for (int count = 0; count < (dimX * dimY); count++) {
            resTime.add(0d);
        }
        for (int i = 0; i < series.size(); i++) {
            double XPo = series.get(i).getX().doubleValue();
            double YPo = series.get(i).getY().doubleValue();
            int arrayIdx = (int) ((Math.round(YPo) * 240) + Math.round(XPo));
            resTime.set(arrayIdx, (resTime.get(arrayIdx) + 1));
        }
        return resTime;
    }

    /**
     * calculate displacement vector from the platform location
     */
    private DataTrace_ver1 displacementVector(DataTrace_ver1 series) {
        DataTrace_ver1 seriesCorr = new DataTrace_ver1();
        for (int i = 0; i < series.size(); i++) {
            double x = series.get(i).getX().doubleValue();
            double y = series.get(i).getY().doubleValue();
            seriesCorr.addData((pX - x), (pY - y));
        }
        return seriesCorr;
    }

    /**
     * calculate velocity vector from the platform location
     */
    private DataTrace_ver1 velocityVector(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 displacement = this.displacementVector(series);
        //delvel                        
        result = this.getSuccessiveDifference(displacement);
        return result;
    }

    /**
     * calculate velocity components along and perpendicular to platform
     */
    private DataTrace_ver1 velocityComponents(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();

        DataTrace_ver1 displacementVector = this.displacementVector(series);
        ArrayList<Double> RDist = this.vectorMagnitude(displacementVector);
        DataTrace_ver1 velocityVector = this.velocityVector(series);
        ArrayList<Double> RVel = this.vectorMagnitude(velocityVector);
        ArrayList<Double> ThetaVel = new ArrayList<>();
        //Calculate ThetaVel and RVelaP
        for (int k = 0; k < (series.size() - 1); k++) {
            double delVel_x = velocityVector.get(k).getX().doubleValue();
            double delVel_y = velocityVector.get(k).getY().doubleValue();
            double seriesCorr_x = displacementVector.get(k).getX().doubleValue();
            double seriesCorr_y = displacementVector.get(k).getY().doubleValue();
            double value = ((delVel_x * seriesCorr_x) + (delVel_y * seriesCorr_y)) / (RDist.get(k) * RVel.get(k));
            ThetaVel.add(k, Math.acos(value));
            double xvalue = RVel.get(k) * Math.cos(ThetaVel.get(k));
            double yvalue = RVel.get(k) * Math.sin(ThetaVel.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate x and y of velocity components along platform
     */
    private DataTrace_ver1 velocityAlongPt(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 velocityComponents = this.velocityComponents(series);
        ArrayList<Double> theta = this.vectorAngle(this.displacementVector(series));
        for (int k = 0; k < velocityComponents.size(); k++) {
            double xvalue = (double) velocityComponents.getX().get(k) * Math.cos(theta.get(k));
            double yvalue = (double) velocityComponents.getX().get(k) * Math.sin(theta.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate x and y of velocity components perpendicular to platform
     */
    private DataTrace_ver1 velocityPerpendicularPt(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();
        DataTrace_ver1 velocityComponents = this.velocityComponents(series);
        ArrayList<Double> theta = this.vectorAngle(this.displacementVector(series));
        for (int k = 0; k < velocityComponents.size(); k++) {
            double xvalue = (double) velocityComponents.getY().get(k) * Math.cos(90 + theta.get(k));
            double yvalue = (double) velocityComponents.getY().get(k) * Math.sin(90 + theta.get(k));
            result.addData(xvalue, yvalue);
        }
        return result;
    }

    /**
     * calculate velocity error vectors
     */
    private DataTrace_ver1 velocityErrorVector(DataTrace_ver1 series) {
        DataTrace_ver1 result = new DataTrace_ver1();

        DataTrace_ver1 displacementVector = this.displacementVector(series);
        ArrayList<Double> RDist = this.vectorMagnitude(displacementVector);
        DataTrace_ver1 velocityVector = this.velocityVector(series);
        DataTrace_ver1 RVel = this.displacementVector(series);

        for (int k = 0; k < (series.size() - 1); k++) {
            //calculate unit vector
            double cap_x = displacementVector.get(k).getX().doubleValue();
            double cap_y = displacementVector.get(k).getY().doubleValue();
            //velocity vector along platform
            double velValueX = velocityVector.get(k).getX().doubleValue();
            double velValueY = velocityVector.get(k).getY().doubleValue();
            //calculate difference between velocity vector along pt and velocity vector i.e. vel error vector
            result.addData(((velValueX * cap_x) - velValueX), ((velValueY * cap_y) - velValueY));
        }
        return result;
    }

    /**
     * save heat map
     */
    private void saveHeatMap(String title, ImageProcessor ip) {
        ImagePlus imp = new ImagePlus(title, ip);
        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + imp.getTitle() + ".tif");
    }

    /**
     * calculate each pixel value given xy data points in DataTrace_ver1
     */
    private ImagePlus sumPixelsImage(DataTrace_ver1 curSeries, ArrayList<Double> M) {
        ImagePlus image = new ImagePlus();
        ImageProcessor ip = new FloatProcessor(dimX, dimY);
        float[][] ipArray = ip.getFloatArray();
//        ArrayList<Double> array = new ArrayList<>();

//        for (int count = 0; count < (dimX * dimY); count++) {
//            array.add(0d);
////                result.add(Float.NaN); //CANNOT USE THIS WHEN YOU WANT TO USE IMAGE FOR DIFFERENTIALS PLUGIN
//        }
        int size = M.size();
        for (int j = 0; j < size; j++) {
            double XPo = curSeries.get(j).getX().doubleValue();
            double YPo = curSeries.get(j).getY().doubleValue();
//            int arrayIdx = (int) ((Math.round(YPo) * 240) + Math.round(XPo));
            int xPix = (int) Math.round(XPo);
            int yPix = (int) Math.round(YPo);
//            array.set(arrayIdx, (array.get(arrayIdx) + M.get(j)));
            ipArray[xPix][yPix] = (float) (ipArray[xPix][yPix] + M.get(j));
            //NOTE: CANNOT USE NANs WHEN USING ImageCalculator/SurfaceFit/Differentials plugin
        }
        ip.setFloatArray(ipArray);
        image.setProcessor(ip);
        return image;
    }

    /**
     * generate residence time weighted heat map
     */
    private ImagePlus resTimeWeightedMap(ImageProcessor resTimeMap, ImageProcessor measureMap) {
        ImagePlus imagePlus = new ImagePlus();
        ImageProcessor ip = new FloatProcessor(dimX, dimY);
        float[][] resTime = resTimeMap.getFloatArray();
        float[][] measure = measureMap.getFloatArray();

        float[][] image = new float[dimX][dimY];
        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                if (resTime[X][Y] != 0) {
                    image[X][Y] = (float) (measure[X][Y] / resTime[X][Y]);
                } else {
                    image[X][Y] = 0f;
                }
            }
        }
        ip.setFloatArray(image);
        imagePlus.setProcessor(ip);
        return imagePlus;
    }

    /**
     * generate vector map
     */
    private ImagePlus vectorMap(ImagePlus xImage, ImagePlus yImage, String resultName) {
        ImagePlus result = null;
//        float[][] xFloatArray = xImage.getProcessor().getFloatArray();
//        float[][] yFloatArray = yImage.getProcessor().getFloatArray();
        ImageProcessor xImg = xImage.getProcessor();
        ImageProcessor yImg = yImage.getProcessor();

        double[] xBegin = new double[dimX * dimY];
        double[] yBegin = new double[dimX * dimY];
        double[] xEnd = new double[dimX * dimY];
        double[] yEnd = new double[dimX * dimY];
        ArrayList<Double> X0 = new ArrayList<>();
        ArrayList<Double> Y0 = new ArrayList<>();
        ArrayList<Double> X1 = new ArrayList<>();
        ArrayList<Double> Y1 = new ArrayList<>();

        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
                int arrayIdx = (Y * dimX) + X;
                float xPixelValue = xImg.getPixelValue(X, Y);
                float yPixelValue = yImg.getPixelValue(X, Y);
                if(xPixelValue !=0 && yPixelValue !=0){
                xBegin[arrayIdx] = X;
                yBegin[arrayIdx] = Y;
                xEnd[arrayIdx] = xPixelValue + X;
                yEnd[arrayIdx] = yPixelValue + Y;
            }
        }
        }
        Plot vectorMap = new Plot(resultName + " vector plot", "X Axis", "Y Axis");
        vectorMap.setLimits(0, dimX, 0, dimY);
        vectorMap.drawVectors(xBegin, yBegin, xEnd, yEnd);
        vectorMap.drawVectors(X0, Y0, X1, Y1);
        vectorMap.show();
        result = vectorMap.getImagePlus();
        return result;
    }

    /**
     * generate polynomial surface fit of order 3
     */
    private ImagePlus thresholdedSurfaceFit3(ImageProcessor ipResTime, ImagePlus image) {

//    private ImagePlus thresholdedSurfaceFit3(ImagePlus ResTime, ImagePlus image) {
//        ImageProcessor ipResTime = ResTime.getProcessor();
        //threshold out 0 values and create an ROI in restime image
        double minValue = 1;
        double maxValue = ipResTime.getMax();
//        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        ipResTime.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(ipResTime);
        Rectangle bounds = selectionROI.getBounds();
//        System.out.println("Bounding rect" + bounds);
        image.setRoi(selectionROI);

        //polynomial fit function -
        Polynomial_Surface_Fit psf = new Polynomial_Surface_Fit(image);
        image = psf.run(image.getProcessor());
//        image.show();
        return image;
    }

    /**
     * generate divergence
     */
    private ImagePlus divergence(ImagePlus xImage, ImagePlus yImage) {

//    private ImagePlus divergence(ImagePlus ResTime, ImagePlus xImage, ImagePlus yImage) {
//        xImage = this.thresholdedSurfaceFit3(ResTime, xImage);
//        yImage = this.thresholdedSurfaceFit3(ResTime, yImage);
        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(xImage, 6); //differentiate wrt x        
        diffJB.run2(yImage, 7); //differentiate wrt y
        //add images
        yImage.getProcessor().copyBits(xImage.getProcessor(), 0, 0, Blitter.ADD);
        return yImage;
    }

    /**
     * generate curl
     */
    private ImagePlus curl(ImagePlus xImage, ImagePlus yImage) {

//    private ImagePlus curl(ImagePlus ResTime, ImagePlus xImage, ImagePlus yImage) {
//        xImage = this.thresholdedSurfaceFit3(ResTime, xImage);
//        yImage = this.thresholdedSurfaceFit3(ResTime, yImage);
//differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(yImage, 6); //differentiate wrt x
        diffJB.run2(xImage, 7); //differentiate wrt y        
        //subtract images
        yImage.getProcessor().copyBits(xImage.getProcessor(), 0, 0, Blitter.DIFFERENCE);
        return yImage;
    }

    /**
     * generate gradient
     */
    private ImagePlus gradient(ImagePlus image) {

//    private ImagePlus gradient(ImagePlus ResTime, ImagePlus image) {
//    image = this.thresholdedSurfaceFit3(ResTime, image);
        //differentiate image
        Differentials_JB diffJB = new Differentials_JB();
        diffJB.run2(image, 0); //gradient magnitude
        return image;
    }

    /**
     * resize surface fit-differential images to dimX by dimY dimensions
     */
    private ImagePlus resizeImage(ImageProcessor ipResTime, ImageProcessor ip) {
        ImagePlus imp = new ImagePlus();
        OvalRoi pool = new OvalRoi(0, 0, 240, 240);

        //threshold out 0 values and create an ROI in restime image
        double minValue = 1;
        double maxValue = ipResTime.getMax();
//        System.out.println("minValue: " + minValue + "maxValue: " + maxValue);
        ipResTime.setThreshold(minValue, maxValue, 3);
        ThresholdToSelection tts = new ThresholdToSelection();
        Roi selectionROI = tts.convert(ipResTime);
        Rectangle bounds = selectionROI.getBounds();

//      resize image to 240 by 240 dimension
        float[][] processedArray = new float[dimX][dimY];
        for (int Y = 0; Y < dimY; Y++) {
            for (int X = 0; X < dimX; X++) {
//                processedArray[X][Y] = Float.NaN;
                processedArray[X][Y] = 0;
            }
        }
        int xb = (int) bounds.getX();  //already defined above
        int yb = (int) bounds.getY();  // already defined above
        int xbmax = (int) bounds.getWidth();
        int ybmax = (int) bounds.getHeight();
        float[][] f = ip.getFloatArray();
        for (int Y = 0; Y < ybmax; Y++) {
            for (int X = 0; X < xbmax; X++) {
                if (pool.containsPoint(X + xb, Y + yb)) {
                    processedArray[X + xb][Y + yb] = f[X][Y];
                }
            }
        }
        ImageProcessor processedip = new FloatProcessor(processedArray);
        imp.setProcessor(processedip);
        return imp;
    }

    /**
     * resize surface fit-differential images to dimX by dimY dimensions
     */
    private float RmFromPolynomialFit(DataTrace_ver1 distVmeasure, String resultName, String mouse) {
        //1st: fit to polynomial, get parameters of fit and plot
        //convert dataTrace's arraylist<Double> to double[]
        ArrayList<Double> dbl = (ArrayList<Double>) distVmeasure.getX();
        double[] xData = dbl.stream()
                .mapToDouble(Double::doubleValue)
                .toArray();
        dbl = (ArrayList<Double>) distVmeasure.getY();
        double[] yData = dbl.stream()
                .mapToDouble(Double::doubleValue)
                .toArray();
        CurveFitter cf = new CurveFitter(xData, yData);
        cf.doFit(CurveFitter.POLY2);
        double[] para = cf.getParams();
        Plot plot = cf.getPlot();

        //2nd: save decorate plot and save plot
        plot.setXYLabels("Distance", resultName);
        String title = "Dist vs R" + resultName + "_M" + mouse;
//                        PlotWindow pw = plot.show();
//                        pw.setTitle(title);
        ImagePlus imp = plot.getImagePlus();
        imp.setTitle(title);
        new FileSaver(imp).saveAsTiff(dir.getPath() + File.separator + title + ".tif");

        //3rd: calculate Rm from fit parameters
        double B0 = para[0];
        double B1 = para[1];
        double B2 = para[2];
        double[] Rm = new double[3];
        double det = 48.10488 + (72 * B1);
        double thetam1 = (9.42 + Math.sqrt(det)) / 6;
        double thetam2 = (9.42 - Math.sqrt(det)) / 6;
        double RmValue = (Math.pow(thetam1, 2) - (3.14 * thetam1) + 3.287) / (2 * (B2 + 1));
        Rm[0] = thetam1;
        Rm[1] = thetam2;
        Rm[2] = RmValue;

        return (float) RmValue;
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;

                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);

        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(WMSoftwareGUI.class
                    .getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new WMSoftwareGUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupPlotGroupDataBy;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButtonCalculateMeasures;
    private javax.swing.JButton jButtonGenerateMaps;
    private javax.swing.JButton jButtonGeneratePlots;
    private javax.swing.JButton jButtonReadFiles;
    private javax.swing.JButton jButtonUploadFiles;
    private javax.swing.JCheckBox jCheckBoxASCIIvector;
    private javax.swing.JCheckBox jCheckBoxAverageMouse;
    private javax.swing.JCheckBox jCheckBoxAverageMousePlot;
    private javax.swing.JCheckBox jCheckBoxCurl;
    private javax.swing.JCheckBox jCheckBoxDivergence;
    private javax.swing.JCheckBox jCheckBoxGradient;
    private javax.swing.JCheckBox jCheckBoxHeatMap;
    private javax.swing.JCheckBox jCheckBoxRDist;
    private javax.swing.JCheckBox jCheckBoxRDistvRVel;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelErr;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelaP;
    private javax.swing.JCheckBox jCheckBoxRDistvRVelpP;
    private javax.swing.JCheckBox jCheckBoxRVel;
    private javax.swing.JCheckBox jCheckBoxRVelErr;
    private javax.swing.JCheckBox jCheckBoxRVelaP;
    private javax.swing.JCheckBox jCheckBoxRVelpP;
    private javax.swing.JCheckBox jCheckBoxResTime;
    private javax.swing.JComboBox<String> jComboBoxTrialNo;
    private javax.swing.JDialog jDialog1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabelMaps;
    private javax.swing.JLabel jLabelMaps1;
    private javax.swing.JLabel jLabelPlots;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JTabbedPane jTabbedPane1;
    private javax.swing.JTextField jTextFieldTotalMiceNo;
    private javax.swing.JTextField jTextFieldTrials;
    private javax.swing.JTextField jTextFieldUserBin;
    // End of variables declaration//GEN-END:variables
}
